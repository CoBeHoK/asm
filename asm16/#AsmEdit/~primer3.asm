          ;== СОРТИРОВКА МАССИВА ==

 .model tiny
 .code    
  org 100h  
  include _macro.txt ;подключение макросов
Start:                  

  CLS          ;макрос очистки экрана
  TEXT T1      ;поясняющий текст
  call MASS    ;печать массива до сортировки

Metka3:                 
  mov BX,offset Y ;адрес массива
  mov CX, K-1  ;цикл - на 1 раз меньше количества
  mov DL, 0    ;флаг: предполашаем, что обмена не будет

Metka2:                 
        ;-сравнение ячеек [BX] и [BX+1]
  mov AX,[BX]  ;взять из двух ячеек в AH и AL
  cmp AH,AL
  ja Metka1    ;если стоят правильно, то не делать обмен
               ; (по возрастанию: JA, убыванию:  JB )


        ;-обмен ячеек [BX] и [BX+1]

; mov AX,[BX]  ;взять из двух ячеек (не обязательно -уже взято)
  xchg AH,AL   ;обменять байты
  mov [BX],AX  ;записать в две ячейки
  mov DL, 1    ;флаг: обмен был

Metka1:                 
  inc BX       ;по массиву вниз
  dec CX    
  jnz Metka2   ;продолжить просмотр массива
  cmp DL, 1 
  jz Metka3    ;был факт обмена, повторить проход по масиву

  TEXT T2      ;поясняющий текст
  call MASS    ;печать массива после сортировки

  PAUSE        ;макрос паузы
  STOP         ;макрос выхода из программы

 include _pp.txt ;подключение подпрограмм


       ;==подпрограмма печати массива
Mass:                 
  mov BX,0      ;нач.индекс
  mov CX,K      ;кол-во элементов
M1:                     
  mov AL,Y[BX]  ;элемент
  call PRINT_AL ;п/п печати байта
  WRITE ' '     ;макрос печати пробела
  inc BX    
  dec CX    
  jnz M1    
  WRITELN       ;макрос перевода курсора
  ret           ;возврат из подпрограммы

 Y db 3,5,2,4,1 ;массив чисел
 K =  $ - Y     ;определение длины массива
 T1 db "Массив до    сортировки: ",'$'
 T2 db "Массив после сортировки: ",'$'
end Start
